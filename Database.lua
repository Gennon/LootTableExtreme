-- LootTableExtreme Database
-- Contains npc loot tables for WoW Classic

LootTableExtreme.Database = {}
local DB = LootTableExtreme.Database

-- Item quality constants
DB.Quality = {
    POOR = 0,
    COMMON = 1,
    UNCOMMON = 2,
    RARE = 3,
    EPIC = 4,
}

-- Item class constants (for GetItemInfo classID return value)
DB.ItemClass = {
    QUEST = 12,  -- Quest items in Classic WoW
}

-- NPCs loot table
-- This is populated by LootDatabase_(vanilla|TBC).lua which is auto-generated by the scraper
DB.NpcLoot = {}

-- NPC ID to npc name lookup
DB.NpcIdToName = {}

-- Reverse lookup: Find which npcs drop a specific item
-- This is built dynamically from the npc loot table
DB.ItemSources = {}

-- Reverse lookup: Find which vendors sell a specific item
-- This is built dynamically from the vendor items table
DB.ItemVendors = {}

function DB:BuildItemSourcesCache()
    self.ItemSources = {}
    self.NpcIdToName = {}
    
    for npcName, npcData in pairs(self.NpcLoot) do
        -- Build NPC ID index
        if npcData.npcId then
            self.NpcIdToName[npcData.npcId] = npcName
        end
        
        if npcData.loot then
            for _, item in ipairs(npcData.loot) do
                if not self.ItemSources[item.itemId] then
                    self.ItemSources[item.itemId] = {}
                end
                
                table.insert(self.ItemSources[item.itemId], {
                    npcName = npcName,
                    dropChance = item.dropChance,
                    zone = npcData.zone,
                    level = npcData.level,
                    elite = npcData.elite or false,
                })
            end
        end
    end
    
    -- Sort each item's sources by drop chance (highest first)
    for itemId, sources in pairs(self.ItemSources) do
        table.sort(sources, function(a, b)
            return a.dropChance > b.dropChance
        end)
    end
end

function DB:BuildItemVendorsCache()
    self.ItemVendors = {}
    
    for vendorName, vendorData in pairs(self.VendorItems or {}) do
        if vendorData.items then
            for _, item in ipairs(vendorData.items) do
                -- Skip items with 0 or nil cost (likely data errors)
                if item.cost and item.cost > 0 then
                    if not self.ItemVendors[item.itemId] then
                        self.ItemVendors[item.itemId] = {}
                    end
                    
                    table.insert(self.ItemVendors[item.itemId], {
                        vendorName = vendorName,
                        cost = item.cost,
                        zone = vendorData.zone,
                        level = vendorData.level,
                        faction = vendorData.faction,
                        factionId = vendorData.factionId,
                        reactionAlliance = vendorData.reactionAlliance,
                        reactionHorde = vendorData.reactionHorde,
                    })
                end
            end
        end
    end
    
    -- Sort each item's vendors by cost (lowest first)
    for itemId, vendors in pairs(self.ItemVendors) do
        table.sort(vendors, function(a, b)
            return a.cost < b.cost
        end)
    end
end

-- Get loot table for a specific NPC
-- Enriches the data with item information from WoW API
function DB:GetLootByNpcName(npcName)
    local npcData = self.NpcLoot[npcName]
    if not npcData then
        return nil
    end
    
    -- Enrich loot data with WoW item information
    if npcData.loot then
        for _, item in ipairs(npcData.loot) do
            -- Always check for quest item status if not already determined
            if item.isQuestItem == nil and item.itemId then
                item.isQuestItem = self:IsQuestItem(item.itemId)
            end
            
            if not item.name then
                -- Fetch item data from WoW API
                local itemName, itemLink, itemQuality, _, _, _, _, _, _, itemTexture = GetItemInfo(item.itemId)
                if itemName then
                    item.name = itemName
                    item.quality = itemQuality or DB.Quality.COMMON
                    item.texture = itemTexture
                end
            end
        end
    end
    
    return npcData
end

-- Get loot table by NPC ID
function DB:GetLootByNpcId(npcId)
    local npcName = self.NpcIdToName[npcId]
    
    if npcName then
        local data = self:GetLootByNpcName(npcName)
        return data, npcName
    end
    return nil, nil
end

-- Helper function to count table entries
function DB:TableCount(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

-- Check if an item is a quest item
function DB:IsQuestItem(itemId)
    if not itemId then return false end
    
    -- First try using GetItemInfo to check item class (quest items use ItemClass.QUEST in Classic)
    local itemName, itemLink, itemQuality, itemLevel, itemMinLevel, itemType, itemSubType, itemStackCount, 
          itemEquipLoc, itemTexture, sellPrice, classID = GetItemInfo(itemId)
    
    -- In Classic WoW, quest items have classID matching DB.ItemClass.QUEST (if GetItemInfo returns it)
    -- Note: GetItemInfo may return nil if item not cached yet
    if classID and classID == self.ItemClass.QUEST then
        return true
    end
    
    -- If GetItemInfo returned data but classID is not QUEST, it's definitely not a quest item
    if itemName and classID and classID ~= self.ItemClass.QUEST then
        return false
    end
    
    -- If we get here, item info hasn't loaded yet - trigger a load and return nil
    -- to indicate we don't know the status yet (caller should handle this)
    if not itemName then
        -- Request item info to trigger GET_ITEM_INFO_RECEIVED event
        GetItemInfo(itemId)
        return nil
    end
    
    -- Fallback: scan tooltip for quest-related text (for when classID not available but item is cached)
    if not self.scanTooltip then
        self.scanTooltip = CreateFrame("GameTooltip", "LootTableExtremeScanTooltip", nil, "GameTooltipTemplate")
        self.scanTooltip:SetOwner(UIParent, "ANCHOR_NONE")
    end
    
    self.scanTooltip:ClearLines()
    self.scanTooltip:SetHyperlink("item:" .. itemId)
    
    -- Check tooltip lines for "Quest Item" text (more specific than just "Quest")
    for i = 1, self.scanTooltip:NumLines() do
        local line = getglobal("LootTableExtremeScanTooltipTextLeft" .. i)
        if line then
            local text = line:GetText()
            if text and string.find(text, "Quest Item") then
                return true
            end
        end
    end
    
    return false
end

function DB:GetTopItemSources(itemId, maxResults)
    maxResults = maxResults or 3
    local sources = self.ItemSources[itemId]
    
    if not sources then
        return {}
    end
    
    local result = {}
    for i = 1, math.min(maxResults, #sources) do
        table.insert(result, sources[i])
    end
    
    return result
end

function DB:GetTopItemVendors(itemId, maxResults)
    maxResults = maxResults or 3
    local vendors = self.ItemVendors[itemId]
    
    if not vendors then
        return {}
    end
    
    local result = {}
    for i = 1, math.min(maxResults, #vendors) do
        table.insert(result, vendors[i])
    end
    
    return result
end

-- Search for NPCs by name
function DB:SearchNpcs(searchTerm)
    searchTerm = string.lower(searchTerm)
    local results = {}
    
    for npcName, npcData in pairs(self.NpcLoot) do
        if string.find(string.lower(npcName), searchTerm, 1, true) then
            table.insert(results, {
                name = npcName,
                zone = npcData.zone,
                level = npcData.level,
            })
        end
    end
    
    return results
end

-- Get quality color
function DB:GetQualityColor(quality)
    local colors = {
        [self.Quality.POOR] = {r = 0.62, g = 0.62, b = 0.62},
        [self.Quality.COMMON] = {r = 1.0, g = 1.0, b = 1.0},
        [self.Quality.UNCOMMON] = {r = 0.12, g = 1.0, b = 0.0},
        [self.Quality.RARE] = {r = 0.0, g = 0.44, b = 0.87},
        [self.Quality.EPIC] = {r = 0.64, g = 0.21, b = 0.93},
    }
    
    return colors[quality] or colors[self.Quality.COMMON]
end

-- Get quality text
function DB:GetQualityText(quality)
    local text = {
        [self.Quality.POOR] = "Poor",
        [self.Quality.COMMON] = "Common",
        [self.Quality.UNCOMMON] = "Uncommon",
        [self.Quality.RARE] = "Rare",
        [self.Quality.EPIC] = "Epic",
    }
    
    return text[quality] or "Unknown"
end

-- Pickpocket loot methods
-- Get pickpocket loot by NPC name
function DB:GetPickpocketByNpcName(npcName)
    local npcData = self.PickpocketLoot and self.PickpocketLoot[npcName]
    if not npcData then
        return nil
    end
    
    -- Enrich loot data with WoW item information
    if npcData.loot then
        for _, item in ipairs(npcData.loot) do
            if not item.name then
                local itemName, itemLink, itemQuality, _, _, _, _, _, _, itemTexture = GetItemInfo(item.itemId)
                if itemName then
                    item.name = itemName
                    item.quality = itemQuality or DB.Quality.COMMON
                    item.texture = itemTexture
                end
            end
        end
    end
    
    return npcData
end

-- Get pickpocket loot by NPC ID
function DB:GetPickpocketByNpcId(npcId)
    if not self.PickpocketLoot then
        return nil, nil
    end
    
    -- Search through pickpocket loot for matching NPC ID
    for npcName, npcData in pairs(self.PickpocketLoot) do
        if npcData.npcId == npcId then
            local data = self:GetPickpocketByNpcName(npcName)
            return data, npcName
        end
    end
    
    return nil, nil
end

-- Check if an NPC has pickpocket loot
function DB:HasPickpocketLoot(npcId)
    if not self.PickpocketLoot then
        return false
    end
    
    for _, npcData in pairs(self.PickpocketLoot) do
        if npcData.npcId == npcId then
            return true
        end
    end
    
    return false
end
